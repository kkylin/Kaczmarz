        - ## REK.jl
        - 
        - ## A Zouzias and NM Freris, "Randomized extended Kaczmarz
        - ## for solving least squares," SIAM J Matrix Anal Appl 34
        - ## (2013), doi:10.1137/120889897
        - 
        - ## This design is perhaps too rigid.
        - 
        - module REK
        - 
        - using LinearAlgebra
        - 
        - export solve
        - 
        - function solve(A::AbstractMatrix{T},
        -                b::AbstractVector{T};
        -                eps = 1e-6,
        -                maxcount=1000) where T <: Number
        - 
        0     m,n = size(A)
        - 
        -     ## precompute rows, their squared sums, and
        -     ## corresponding probabilities
        0     row     = map(i->conj(view(A,i,:)), 1:m)
        0     rowsum  = map(r->sum(abs2,r), row)
       32     rowprob = rowsum ./ sum(rowsum)
        - 
        -     ## same for cols
        0     col     = map(j->view(A,:,j), 1:n)
        0     colsum  = map(c->sum(abs2,c), col)
       32     colprob = colsum ./ sum(colsum)
        - 
        -     ## these are needed for the convergence test
       64     epsFnorm2 = eps^2 * sum(abs2,A)
        0     subcount = 8*min(m,n)
        - 
        -     ## main loop
    16256     z = copy(b)  ## we'll be modifying z and b shouldn't change
      224     x = zeros(T,n)
        - 
   399200     iabs2(i) = abs2(dot(row[i],x) - b[i] + z[i])
       96     jabs2(j) = abs2(dot(col[j],z))
        - 
        0     for c = 1:maxcount
        0         for cc = 1:subcount
      864             i = rpick(rowprob)
        0             j = rpick(colprob)
        - 
    23040             z .-= dot(col[j],z)/colsum[j] .* col[j]
    15360             x .+= (b[i] - z[i] - dot(row[i],x)) / rowsum[i] .* row[i]
        -         end
        -         
      160         tol2 = epsFnorm2 * sum(abs2,x)
        - 
        -         # if norm(A*x .- b .+ z) <= tol && norm(A'*z) <= tol
        0         if ( sum(iabs2,1:m) <= tol2 && sum(jabs2,1:n) <= tol2 )
        0             return x,c*subcount
        -         end
        -     end
        0     return x,maxcount*subcount
        - end
        - 
        - function rpick(probs)
        0     u = rand()
        -     s = 0.0
        0     for i = 1:length(probs)
        0         s += probs[i]
        0         if u <= s
        0             return i
        -         end
        -     end
        0     return length(probs)
        - end
        - 
        - 
        - ## tests
        - 
        - test(m=3,n=3; flags...) = test(Complex{Float64},m,n; flags...)
        - 
        - function test(::Type{Float64},m=3,n=3; flags...)
        -     A = randn(m,n)
        -     b = randn(m)
        -     @time x0 = A\b
        -     @time x1,k = solve(A,b; flags...)
        -     (backslash = x0, kaczmarz = x1, itercount = k) 
        - end
        - 
        - function test(::Type{Complex{Float64}},m=3,n=3; flags...)
        -     A = randn(m,n) + im*randn(m,n)
        -     b = randn(m) + im*randn(m)
        -     @time backslash = A\b
        -     @time kaczmarz,count = solve(A,b; flags...)
        -     print("## ")
        -     @show maximum(abs,backslash-kaczmarz)
        -     print("## ")
        -     @show norm(backslash)
        -     print("## ")
        -     @show norm(kaczmarz)
        -     (backslash = backslash, kaczmarz = kaczmarz, count = count) 
        - end
        - 
        - end#module
